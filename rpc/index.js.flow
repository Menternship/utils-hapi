// @flow
import amqp from 'amqplib/callback_api';
import uuid from 'uuid/v1';
import mirror from 'keymirror-flow';
// $FlowFixMe
const pkg = require(process.env.PWD + '/package.json');

export const types = mirror({
  CREATE_USER: 1,
});

let channel = {};

export const connect = (connection: string) => new Promise((resolve, reject) => {
  amqp.connect(`${connection}`, (err, conn) => {
    if (err) {
      reject(err);
    }
    conn.createChannel((chErr, ch) => {
      if (chErr) {
        reject(chErr);
      }
      ch.prefetch(1);
      channel = ch;
      resolve(ch);
    });
  });
});

export const getPlugin = (connection: string) => {
  const register = (server: Object, options: Object, next: Function) => {
    connect(connection)
    .then(next)
    .catch((err) => {
      console.log(err);
      throw err;
    });
  };
  register.attributes = {
    name: 'RPC_PLUGIN',
    version: pkg.version,
  };
  return register;
};

type $serverObject = {
  [key: string]: [(arg: any) => Promise<any>, ?Object];
};

class RPC {
  constructor(cha: any) {
    this.ch = cha || channel;
  }
  processServers = (servers: $serverObject[]) => {
    Object.keys(servers).map((type) => {
      return this.createServer(type, servers[type][0], servers[type][1]);
    });
  }
  createServer = (name: string, callbackProm: any, options?: Object = {}) => {
    this.ch.assertQueue(name, { durable: true, ...options });
    this.ch.consume(
      name,
      msg => (callbackProm(msg.content, msg.properties.error))
      .then((resp) => {
        this.ch.sendToQueue(msg.properties.replyTo, resp, {
          correlationId: msg.properties.correlationId,
        });
      }),
    );
  }
  createClient = (name: string, sendMsg, callbackProm) => {
    return new Promise((resolve, reject) => {
      this.ch.assertQueue('', { exclusive: true }, (err, q) => {
        if (err) {
          reject(err);
        }
        const corr = uuid();
        this.ch.consume(q.queue, (msg) => {
          if (msg.properties.correlationId === corr) {
            resolve(callbackProm(msg.content));
          }
        }, { noAck: true });
        this.ch.sendToQueue(name,
          sendMsg,
        { correlationId: corr, replyTo: q.queue });
      });
    });
  }
}

const checkConnected = (attempt = 0, resolve, reject) => {
  if (Object.keys(channel).length) {
    return resolve(new RPC());
  }
  if (attempt > 200) {
    return reject(new Error('Could not connect to rabbitmq'));
  }
  return setTimeout(() => checkConnected(attempt + 1, resolve), 500);
};

const startRPC = () => new Promise((resolve, reject) => {
  checkConnected(0, resolve, reject);
});

export default startRPC;
